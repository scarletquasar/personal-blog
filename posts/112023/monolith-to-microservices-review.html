<!doctype html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="/css/reset.css" />
        <link rel="stylesheet" href="/css/global.css" />
        <link rel="stylesheet" href="/css/mobile.css" />
        <link rel="stylesheet" href="/css/desktop.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith - Review - Unfinished - Scarlet Victoria Rose</title>
    </head>
    <body>
        <main>
            <nav>
                <img width="45" height="45" src="https://img.icons8.com/ios/50/FFFFFF/lambda.png" alt="lambda"/>
                <h1><a href='../../index.html'>Scarlet Victoria</a></h1>
            </nav>
            <div id="links">
                <a href='../../posts.html'>posts</a>
                <a target='_blank' href='https://github.com/scarletquasar'>github</a>
                <a target='_blank' href='https://dev.to/scarlet'>dev.to</a>
            </div>
            <section>
                <h1 class="article-title">
                    (Unfinished) (wont-work) Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith - Sam Newman
                </h1>
                <p>
                    The book starts away bringing core keywords about microservices: what they are, how they are supposed to
                    behave, what is the cost of having different applications inside the same business aggregate and other important
                    matters. Along the book's chapters it is possible to perceive that the author tries to not keep any opinion,
                    bringing only the overall and explaining a bit about some patterns that can be used in each step of the migration
                    from a coupled monolith to a fully functional microservices architecture. 
                </p>

                <h2>Just Enough Microservices</h2>
                <p>
                    The first chapter, <b>Just Enough Microservices</b>, brings a overall of the thoughts strictly needed before deciding
                    if microservices are the solution to the problems that the reader is having, but the chapter itself tries to explain 
                    how different architectures are designed and how the teams arrangement will affect directly in this design. After some 
                    pages of an extended and not very necessary explanation about that we get a very superficial description about performance
                    and conflict problems that was not very satisfactory and had a lack of real world examples.
                </p>
                <p>
                    About profitable spots of this chapter, it is not failing in parts like explaining key terms, like coupling/decoupling and
                    the relationship with advantages and disvantages, talking about how a monolith can be profitable in applications that are
                    new to the market and a satisfactory overwview about domain driven design. With that, the reader gracefully ends the chapter
                    knowing a satisfactory amount about domain driven designs and with a basic view to identify that in real world cases.
                </p>

                <h2>Planning a Migration</h2>
                <p>
                    The "Planning a Migration" chapter starts questioning the reader: is a microservices migration really neccessary? Don't
                    you prefer using a modular monolith? And starts explaining about that with some real use-cases where teams didn't
                    actually need microservices but din't really think about building a modular monolith. But the concern is: Sam knew that
                    microservices are a cool idea and would sound perfect for any unexperienced team as a solution for all the problems, but
                    he also knew that it is not true and could cause a lot of new problems that would bring the effect "sunk cost fallacy" - where
                    the cost of the operations could not be recovered, ever.
                </p>
                <p>
                    What can cause "sunk cost fallacy" in that context? - Let's suppose you have a small team (I'm talking about 3 - 4) developers
                    and the product (application) that is a coupled monolith starts having performance problems and is in a point where the
                    codebase is almost unmaintainable. Without knowing - due to the difficulty to debug and discover the real problems of
                    the application - that the performance problem was related uniquely to the database overload since there is no caching strategy
                    at all in the code, they make a unplanned and decide to implement "microservices". Months later the company starts losing
                    the triple of the money that it firstly paid in overall infrastructure, but why? According to the book the process can
                    start failing in two points.
                </p>
                <p>
                    The first point is maintainability: a migration won't be suitable for changes and refactoring. If the application is already
                    hard to maintain, migrating it directly to a microservices structure can be a hard thing, but the real problem is when the
                    developers try to rewrite the code behavior (famous "refactoring without tests") and fix common problems during the migration -
                    what can cause even more problems due to the lack of a solid code to use as truth base.
                </p>
                <p>
                    The second point is responsibility segregation: with diverse microservices that are not actively worked on, a lot of unexpected
                    behaviors can happen, for example, some responsibilities can be messy or separated, like two different microservices participating
                    in doing the same thing or one single microservices with more than one responsibility.
                </p>

                <h2>Splitting a monolith</h2>
                <p>
                    In this chapter, Sam talks about the preparatives to start actully splitting the existing codebase in different microservices, so,
                    to start deep diving on that, the first point to be discussed about is if the monolith will be changed during a migration or not.
                    At first you can think: maybe we can just keep the work going on the monolith while we migrate the code and create the services, but
                    that's not how it works, there are a lot of things to think about when migrating a code that is already being touched - actively.
                </p>
                <p>
                    To reduce possible conflicts, Sam suggests starting by the easiest services to be separated, like helper services, background tasks
                    and other things that are not part of the main behavior of the program. In the book he quotes a lot of interesting use cases and also
                    creates a new example where he can properly explain everything to know about this kind of decoupling.
                </p>
            </section>
        </main>
        <footer>
            <script>
                const footerText = `Scarlet Victoria © ${new Date().getFullYear().toString()}`;
                document.getElementsByTagName("footer")[0].innerHTML = footerText;
            </script>
            <noscript>
                © Scarlet Victoria
            </noscript>
        </footer>   
    </body>
</html>
